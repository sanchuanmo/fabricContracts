package chaincode_test

import (
	"encoding/json"
	"fmt"
	"testcontract/chaincode"
	"testcontract/chaincode/mocks"
	"testing"

	"github.com/hyperledger/fabric-protos-go/ledger/queryresult"
	"github.com/stretchr/testify/require"
)

/*
These unit tests use mocks to simulate chaincode-api & fabric interactions
The mocks are generated using counterfeiter directives in the comments (starting with "go:generate counterfeiter")
All files in mocks/* are generated by running following, in the directory with your directive:
	`go generate`
*/

/*
 GetStateReturns只能设置一次GetStubReturn的结果，当Get访问不同的结果时，无法执行多次。
 GetStateReturnsOnCall设置列表形式的多个GetStubReturn的结果，可用于多次访问Get不同结果时使用。
*/

func TestInitLedger(t *testing.T) {
	chaincodeStub := &mocks.ChaincodeStub{}
	transactionContext := &mocks.TransactionContext{}
	transactionContext.GetStubReturns(chaincodeStub)

	assetTransfer := chaincode.SmartContract{}
	err := assetTransfer.InitLedger(transactionContext)
	require.NoError(t, err)
}

func TestReadAssetGlobal(t *testing.T) {
	chaincodeStub := &mocks.ChaincodeStub{}
	transactionContext := &mocks.TransactionContext{}
	transactionContext.GetStubReturns(chaincodeStub)

	assetTransfer := chaincode.SmartContract{}
	//读取assetGlobal
	expectedAssetGlobal := &chaincode.AssetGlobal{IdNum: 0}
	bytesExpectedAssetGlobal, err := json.Marshal(expectedAssetGlobal)
	require.NoError(t, err)
	chaincodeStub.GetStateReturns(bytesExpectedAssetGlobal, nil)
	assetBlobal, err := assetTransfer.ReadAssetGlobal(transactionContext)
	require.NoError(t, err)
	require.EqualValues(t, expectedAssetGlobal, assetBlobal)
}

func TestCreateAsset(t *testing.T) {
	chaincodeStub := &mocks.ChaincodeStub{}
	transactionContext := &mocks.TransactionContext{}
	transactionContext.GetStubReturns(chaincodeStub)

	assetTransfer := chaincode.SmartContract{}
	//读取assetGlobal
	expectedAssetGlobal := &chaincode.AssetGlobal{IdNum: 0}
	bytesExpectedAssetGlobal, err := json.Marshal(expectedAssetGlobal)
	require.NoError(t, err)
	chaincodeStub.GetStateReturnsOnCall(0, bytesExpectedAssetGlobal, nil)
	//读取asset判断asset是否存在
	chaincodeStub.GetStateReturnsOnCall(1, nil, nil)

	err = assetTransfer.CreateAsset(transactionContext, "", 0, "", 0)
	require.NoError(t, err)
}

func TestReadAsset(t *testing.T) {
	chaincodeStub := &mocks.ChaincodeStub{}
	transactionContext := &mocks.TransactionContext{}
	transactionContext.GetStubReturns(chaincodeStub)

	assetTransfer := chaincode.SmartContract{}
	//预定存入数据
	expectedAsset := &chaincode.Asset{DocType: "", ID: "0000000000000001", Color: "", Size: 0, Owner: "", AppraisedValue: 0}
	bytes, err := json.Marshal(expectedAsset)
	require.NoError(t, err)
	chaincodeStub.GetStateReturns(bytes, nil)
	// 判断获取记录结果是否一致
	exist, err := assetTransfer.ReadAsset(transactionContext, 0)

	require.NoError(t, err)
	require.Equal(t, expectedAsset, exist)
}

func TestUpdateAsset(t *testing.T) {
	chaincodeStub := &mocks.ChaincodeStub{}
	transactionContext := &mocks.TransactionContext{}
	transactionContext.GetStubReturns(chaincodeStub)

	expectedAsset := &chaincode.Asset{ID: "asset1"}
	bytes, err := json.Marshal(expectedAsset)
	require.NoError(t, err)
	chaincodeStub.GetStateReturns(bytes, nil)

	assetTransfer := chaincode.SmartContract{}
	err = assetTransfer.UpdateAsset(transactionContext, 1, "", 0, "", 0)
	require.NoError(t, err)

	chaincodeStub.GetStateReturns(nil, nil)
	err = assetTransfer.UpdateAsset(transactionContext, 1, "", 0, "", 0)
	require.EqualError(t, err, "asset not exists: 1")

	chaincodeStub.GetStateReturns(nil, fmt.Errorf("demo"))
	err = assetTransfer.UpdateAsset(transactionContext, 1, "", 0, "", 0)
	require.EqualError(t, err, "failed to get asset: failed to read asset 0000000000000001 from world state. demo")
}

func TestDeleteAsset(t *testing.T) {
	chaincodeStub, transactionContext := chaincodeStubInit()

	asset := &chaincode.Asset{ID: "0000000000000001"}
	bytes, err := json.Marshal(asset)
	require.NoError(t, err)
	chaincodeStub.GetStateReturns(bytes, nil)
	chaincodeStub.DelStateReturns(nil)
	assetTransfer := chaincode.SmartContract{}
	err = assetTransfer.DeleteAsset(transactionContext, 1)
	require.NoError(t, err)

	chaincodeStub.GetStateReturns(nil, nil)
	err = assetTransfer.DeleteAsset(transactionContext, 1)
	require.EqualError(t, err, "asset not exists: 1")

	chaincodeStub.GetStateReturns(nil, fmt.Errorf("unable to retrieve asset"))
	err = assetTransfer.DeleteAsset(transactionContext, 1)
	require.EqualError(t, err, "failed to get asset: failed to read asset 0000000000000001 from world state. unable to retrieve asset")
}

func TestGetAssetsByRangeLatest(t *testing.T) {
	chaincodeStub, transactionContext := chaincodeStubInit()

	//读取assetGlobal
	expectedAssetGlobal := &chaincode.AssetGlobal{IdNum: 1}
	bytesExpectedAssetGlobal, err := json.Marshal(expectedAssetGlobal)
	require.NoError(t, err)
	chaincodeStub.GetStateReturns(bytesExpectedAssetGlobal, nil)

	asset1 := &chaincode.Asset{ID: "0000000000000000"}
	bytes1, err := json.Marshal(asset1)
	require.NoError(t, err)
	asset2 := &chaincode.Asset{ID: "0000000000000001"}
	bytes2, err := json.Marshal(asset2)
	require.NoError(t, err)

	iterator := &mocks.StateQueryIterator{}
	iterator.HasNextReturnsOnCall(0, true)
	iterator.HasNextReturnsOnCall(1, true)
	iterator.HasNextReturnsOnCall(2, false)
	iterator.NextReturnsOnCall(0, &queryresult.KV{Value: bytes1}, nil)
	iterator.NextReturnsOnCall(1, &queryresult.KV{Value: bytes2}, nil)

	chaincodeStub.GetStateByRangeWithPaginationReturns(iterator, nil, nil)
	expectedAssets := []*chaincode.Asset{asset1, asset2}

	assetTransfer := &chaincode.SmartContract{}
	assets, err := assetTransfer.GetAssetsByRangeLatest(transactionContext, 0, 0)
	require.NoError(t, err)
	require.Equal(t, expectedAssets, assets)
}

func chaincodeStubInit() (*mocks.ChaincodeStub, *mocks.TransactionContext) {
	chaincodeStub := &mocks.ChaincodeStub{}
	transactionContext := &mocks.TransactionContext{}
	transactionContext.GetStubReturns(chaincodeStub)
	return chaincodeStub, transactionContext
}

// mocks没有HistoryQueryIteratorInterface部分的接口及测试类，暂无法进行history记录查询的单元测试
// func TestGetAssetHistory(t *testing.T) {
// 	chaincodeStub, transactionContext := chaincodeStubInit()

// 	asset1 := &chaincode.Asset{ID: "0000000000000000", Color: "blue"}
// 	bytes1, err := json.Marshal(asset1)
// 	require.NoError(t, err)
// 	asset2 := &chaincode.Asset{ID: "0000000000000000", Color: "yellow"}
// 	bytes2, err := json.Marshal(asset2)
// 	require.NoError(t, err)

// 	iterator.HasNextReturnsOnCall(0, true)
// 	iterator.HasNextReturnsOnCall(1, true)
// 	iterator.HasNextReturnsOnCall(2, false)
// 	iterator.NextReturnsOnCall(0, &queryresult.KV{Value: bytes1}, nil)
// 	iterator.NextReturnsOnCall(1, &queryresult.KV{Value: bytes2}, nil)

// }
